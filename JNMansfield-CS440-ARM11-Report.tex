\documentclass[11pt]{report}
\usepackage{fancyhdr}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage{setspace}
\usepackage{url}
\usepackage{hyperref}
\usepackage{float}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{minted}
\usemintedstyle{tango}
\usepackage{mips}
\usepackage[utf8]{inputenc}
%tikz stuff
\usepackage{tikz}
\usetikzlibrary{shapes,shadows,arrows,backgrounds,positioning}
\tikzstyle{box1}=[rectangle, fill=orange!40, text width=1.5cm, rounded corners, text centered,font=\scriptsize, drop shadow]
\tikzstyle{box2}=[rectangle, fill=brown!40, text width=1.5cm, rounded corners, text centered,font=\scriptsize, drop shadow]
\tikzstyle{box3}=[rectangle, fill=gray!40, text width=1.5cm, rounded corners, text centered,font=\scriptsize, drop shadow]
\tikzstyle{box4}=[rectangle, fill=pink!90, text width=1.5cm, rounded corners, text centered,font=\scriptsize,drop shadow]
\tikzstyle{box5}=[rectangle, fill=orange, text width=1.5cm, minimum height=1.2cm, rounded corners, text centered,font=\scriptsize,drop shadow]
%tikz stages
\tikzstyle{stage}=[rectangle, fill=black!90, text=white, rounded corners, text width=1.5cm, text centered,font=\scriptsize,drop shadow]
\tikzstyle{stage2}=[rectangle, fill=black!10, text=black, rounded corners, text width=1.5cm, text centered,font=\scriptsize,drop shadow]
\tikzstyle{stage3}=[rectangle, fill=black!90, text=white, rounded corners, text width=6cm, text centered,font=\scriptsize,drop shadow]
%tikz arrow
\tikzstyle{arrow1}=[single arrow,draw=none, scale=1,minimum height=1cm, fill=red, drop shadow]
\tikzstyle{arrow2}=[single arrow,draw=none, scale=1,minimum height=1cm, fill=blue, drop shadow]
\tikzstyle{arrow3}=[single arrow,draw=none, scale=1,minimum height=1cm, fill=green, drop shadow]
\tikzstyle{arrow4}=[single arrow,draw=none, scale=1,minimum height=1cm, fill=green, rotate=-60, drop shadow]
\tikzstyle{arrow5}=[single arrow,draw=none, scale=1,minimum height=1cm, fill=green, rotate=60, drop shadow]
%tikz stuff end

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=none,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%begining external
\usetikzlibrary{external}
\tikzset{external/system call={latex \tikzexternalcheckshellescape -halt-on-error
-interaction=batchmode -jobname "\image" "\texsource";
dvips -o "\image".ps "\image".dvi;
ps2eps "\image.ps"}}
\tikzexternalize
%end external

\usepackage[backend=biber,
style=authoryear-comp,
natbib=true,
]{biblatex}
\usepackage{titlesec}
\titleformat*{\section}{\Large\bfseries\sffamily\color{Sepia}}
\titleformat*{\subsection}{\large\bfseries\sffamily\color{Bittersweet}}
\titleformat*{\subsubsection}{\large\bfseries\sffamily\color{RedOrange}}
\addbibresource{JNMansfield-CS440-ARM11-Report.bib}
\begin{document}
\lstset{language=[mips]Assembler}
\begin{titlepage}

\begin{center}
\textsc{{\LARGE\color{Sepia}{CS440}}}\\[1.5cm]
\textsc{{\LARGE\color{Bittersweet}{The ARM1176JZF-S Architecture}}}\\[1.5cm]

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{\color{RedOrange}{Author}:}\\
Mr. Jason \textsc{Mansfield}
\end{flushleft}\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{\color{RedOrange}Instructor:} \\
Prof.~Pamela~\textsc{Smallwood}
\end{flushright}
\end{minipage}
\end{center}
\end{titlepage}

\tableofcontents
\clearpage
\section{In the beginning there was Acorn}
\begin{onehalfspace}
In 1985 the first ARM processor, the Acorn RISC Machine was introduced to the world~\citep{levy2005history}. Later in 1990 the Advanced RISC Machines Ltd.(ARM) would be launched. Unlike other RISC processor vendors of their time ARM began creating small scale processors. A whitepaper~\citep{kamath2001system} from 2001 Strategy made this statement: 
\end{onehalfspace}
\begin{quote}
At Wipro, significant focus has been on the ARM processor technology, since we believe that will drive the evolving market for embedded applications, mobile devices and next generation information appliances.
\end{quote}
\begin{onehalfspace}
Although this insight was probably not difficult to gauge by 2001, the scale at which embedded mobile devices has exploded onto the market has been impressive. Larger corporations, which have not been know for ingenuity, such as Microsoft, have been dealt a massive blow by new mobile devices such as Apples IOS based iPhone and iPad, or the fleets of Android based devices. The need for a smaller architecture has never been greater and ARM is sitting center stage. 
\end{onehalfspace}
\subsection{The need for a smaller silicon area}
\begin{onehalfspace}
The ARM architecture a \textbf{Reduced Instruction Set Computer} or RISC based architecture is now considered a dominant choice for developers and manufacturers. The ARM architecture incorporates standard RISC features~\citep[A1-2]{referenceB}:
\end{onehalfspace}

\begin{itemize}
\item a large uniform register file.
\item a load/store architecture, where data-processing operations only operate on register contents, not directly on memory contents.
\item simple addressing modes, with all load/store addresses being determined from register contents and instruction fields only.
\end{itemize}
\begin{onehalfspace}
The ARM architecture has proven to be a better choice for smaller devices due to the low power consumption along with good performance. The \textbf{RM Architecture Reference Manual} listed the following additional reasons ARM is designed for smaller devices~\citep[A1-2]{referenceB}:
\end{onehalfspace}
\begin{itemize}
\item instructions that combine a shift with an arithmetic or logical operation.
\item auto-increment and auto-decrement addressing modes to optimize program loops.
\item Load and Store Multiple instructions to maximize data throughput.
\item conditional execution of almost all instructions to maximize execution throughput.
\end{itemize}
\section{The Instruction Set Architecture}
Currently ARMv6 has ISA support for the following~\citep{ARM1176}:
\begin{itemize}
\item ARM
\item Thumb\textregistered
\item Jazelle DBX\textregistered
\item DSP extension
\item Floating Point Unit
\end{itemize}
\begin{onehalfspace}
\subsection{state switching}
The ARM processor allows switching of states using the BX and BLX instructions. The ARM state is 32-bit word-aligned, the Thumb a 16-bit halfword-aligned, and the Jazelle state is variable length, byte aligned for instructions~\citep[2-12]{arm1176jzf-s}.
\subsection{Conditionalised}
ARM instructions can be whats called conditionalised. If the needs of the condition code are not met the instruction will simply become a NOP:
\end{onehalfspace}

\begin{figure}[H]
\rowcolors{1}{gray!10}{brown!10}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|l|}
\hline
Condition Code & Meaning\\\hline
N & Negative condition code, set to 1 if result is negative\\\hline
Z & Zero condition code, set to 1 if the result of the instruction is 0\\\hline
C & Carry condition code, set to 1 if the instruction result in a carry condition\\\hline
V & Overflow condition code, set to 1 if the instruction results in an overflow condition.\\\hline
\end{tabular}}
\caption{Conditions}
\end{figure}


\begin{onehalfspace}

\subsection{Conditional codes}
Conditional Codes mean Conditional execution. The bit [31:28] determine the condition or lack there of:
\end{onehalfspace}

\begin{center}
\rowcolors{1}{gray!10}{brown!10}
\begin{figure}[H]
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|c|c|c|c|}\hline
cond & mnemonic ext & meaning int & meaning floating point & cond flag\\\hline
0000 & EQ & Equal & Equal & Z==1\\\hline
0001 & NE & Not Equal & Not Equal, or unordered & Z==0\\\hline
0010 & $CS^b$ & Carry set & Greater than, equal, or unordered & C==1\\\hline
0011 & $CC^c$ & Carry clear & Less than & C==0\\\hline
0100 & MI & Minus, negative & Less than & N==0\\\hline
0101 & PL & Plus, positive or zero & Greater than, equal, or unordered & N==0\\\hline
0110 & VS & Overflow & Unordered & V==1\\\hline
0111 & VC & No overflow & Not unordered & V==0\\\hline\hline
1000 & HI & Unsigned higher & Greater than, or unordered & C==1 and Z==0\\\hline
1001 & LS & Unsigned lower or same & Less than or equal & C==0 and Z==0\\\hline\hline
1010 & GE & Signed greater than or equal & Greater than or equal & N==V\\\hline
1011 & LT & Signed less than & Less than, or unordered & N!=V\\\hline
1100 & GT & Signed greater than & Greater than & Z==0 and N==V\\\hline
1101 & LE & Signed less than or equal & Less than, equal, or unordered & Z==1 or N!=V\\\hline\hline
1110 & None $(AL)^d$ & Always(unconditional) & Always(unconditional) & Any\\\hline

\end{tabular}}
\caption{Conditional Codes}
\end{figure}


\end{center}
\subsection{A32}
\begin{onehalfspace}
ARM is also known as A32~\citep{A32}. ARMv6 architecture is amongst a few others which use A32 such as ARMv5TEJ and ARMv4T. 
\subsubsection{ Instruction length and format}
ARM instructions are 32-bits wide and have a 4-byte boundary~\citep{A32}. The subdivisions of the ARM instruction set can be seen in the below figure 1~\citep[A5-2]{referenceB}. As you can see each ARM instruction is composed of a 32-bit word. The 32-bit word's subdivisions are determined by bits [31:25,4]. Additionally, the conditional subdivision can be see between bits [31:28]. The conditional field allows for more optimizations.
\end{onehalfspace}

\begin{center}
\rowcolors{1}{gray!10}{brown!10}
\begin{figure}[H] 
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
31~30~29~28& 27~26~25 & 24~23~22~21~20~19~18~17~16~15~14~13~12~11~10~9~8~7~6~5& 4 & 3~2~1~0\\
\hline
cond & op1 &  & op & \\ \hline
\end{tabular}}
\caption{ARM subdivisions}
\end{figure}
\end{center}
\subsubsection{General Instruction Categories}
\begin{onehalfspace}
The following figure 4, shown below, illustrates the encoding which defines the various classes of instructions used with ARMv6~\citep[A5-2]{referenceB}:
\end{onehalfspace}

\begin{center}
\rowcolors{1}{gray!10}{brown!10}
\begin{figure}[H] 
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|c|c|c|}
\hline
cond & op1 & op & Instruction classes\\ \hline \hline
not 1111 & 00x & - & Data-processing and misc instructions\\ \hline
not 1111 & 010 & - & Load/Store word and unsigned byte\\ \hline
not 1111 & 011 & 0 & Load/Store word and unsigned byte\\ \hline
not 1111 & 011 & 1 & Media instructions\\ \hline
not 1111 & 10x & - & Branch, branch with link, and block data transfer\\ \hline
not 1111 & 11x & - & Supervisor Call and coprocessor instructions\\ \hline \hline
1111 & - & - & Unconditionally executed\\ \hline
\end{tabular}}
\caption{ARM Instruction encoding}
\end{figure}
\end{center}
\subsubsection{The Branch Instruction}
\begin{onehalfspace}
As can be seen in figure 4 op1 determines the instruction class. For example when op1 = 10x one of the various branching or block data transfer instructions is being used. If branch is the instruction specifically being used then 10xxxx will be found between [25:20] as shown in figure 3 below~\citep[A5-27]{referenceB}: 
\end{onehalfspace}

\begin{center}
\rowcolors{1}{gray!10}{brown!10}
\begin{figure}[H] 
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
31~30~29~28& 27~26 & 25~24~23~22~21~20 & 19~18~17~16& 15 & 14~13~12~11~10~9~8~7~6~5~4~3~2~1~0\\
\hline
cond & 1~0 & op &  &  &   \\ \hline
not 1111 & 1~0 & 10xxxx &  & &\\ \hline
\end{tabular}}
\caption{Branch equals 10xxxx}
\end{figure}
\end{center}
\begin{onehalfspace}
Going a step further, the following figure 5 shows the branch instructions details in Encoding A1 with no conditions~\citep[A8-44]{referenceB}.
\end{onehalfspace}
\begin{center}
\rowcolors{1}{gray!10}{brown!10}
\begin{figure}[H] 
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|c|c|}
\hline
31~30~29~28& 27~26~25~24 & 23~22~21~20~19~18~17~16~15~14~13~12~11~10~9~8~7~6~5~4~3~2~1~0\\
\hline
1~1~1~0 & 1~0~1~0& imm24   \\ \hline
\end{tabular}}
\caption{imm32 = SignExtend(imm24:'00', 32);}
\end{figure}
\end{center}
\begin{onehalfspace}
Encoding A1 indicates multiples of 4 in the range $-33554432$ to $33554428$. Other encodings such as T1, T2, T3, and T4 have smaller ranges with T1 being the smallest of the permitted offsets. The T1 range is $-256$ to $254$. All other offset ranges besides Encoding A1 are in even numbers, while Encoding A1, shown in figure 4, is in Multiples of 4. ARM encodings are labeled as A1, A2, A3 and so forth, while Thumb encodings are listed as T1, T2, T3 and so forth. Additionally, there are also encodings for ThumbEE which are listed as E1, E2, E3 and so forth~\citep[A8-282]{referenceB}. 
\end{onehalfspace}
\subsubsection{The MOV Instruction}
\begin{onehalfspace}
Looking back at figure 2 to op1 = 00x you can see the 27th and 26th bit is determined to be both 0 for all instructions defined as data processing and misc. 
\end{onehalfspace}
\begin{center}
\rowcolors{1}{gray!10}{brown!10}
\begin{figure}[H] 
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
31~30~29~28& 27~26 & 25 & 24~23~22~21~20 & 19~18~17~16~15~14~13~12~11~10~9~8 & 7~6~5~4 & 3~2~1~0\\
\hline
cond & 0~0 & op &op1  &  &op2 &  \\ \hline
\end{tabular}}
\caption{Data-processing and misc}
\end{figure}
\end{center}

\begin{onehalfspace}
One instruction which falls under the category of data processing is the MOV instruction. The following figure demonstrates the use of the MOV instruction in encoding A1~\citep[A8-194]{referenceB}. 
\end{onehalfspace}

\begin{center}
\rowcolors{1}{gray!10}{brown!10}
\begin{figure}[H] 
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
31~30~29~28& 27~26 & 25 & 24~23~22~21 & 20 & 19~18~17~16 & 15~14~13~12 & 11~10~9~8~7~6~5~4~3~2~1~0\\
\hline
cond & 0~0 & 1 & 1~1~0~1 & S & (0)(0)(0)(0) & Rd & imm12  \\ \hline
\end{tabular}}
\caption{MOV instruction}
\end{figure}
\end{center}

\subsection{Syntax for using the branch and mov instructions}
\begin{onehalfspace}
The aforementioned instructions mov and branch are used in the following manor: 
\end{onehalfspace}
\begin{figure}
\begin{minted}{gas}
/*an assembly code example using instruction mov*/
.global main
.func main

main:
     mov r0, #11 /* Put the number eleven in register r0*/
     bx lr
\end{minted}
\caption{mov instruction}
\end{figure}

\begin{center}
\rowcolors{1}{gray!10}{brown!10}
\begin{figure}[H] 
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
31~30~29~28& 27~26 & 25 & 24~23~22~21 & 20 & 19~18~17~16 & 15~14~13~12 & 11~10~9~8~7~6~5~4~3~2~1~0\\
\hline
1~1~1~0 & 0~0 & 1 & 1~1~0~1 & 0 & 0~0~0~0 & 0~0~0~0 & 0~0~0~0~0~0~0~0~1~0~1~1  \\ \hline
\end{tabular}}
\caption{MOV r0, \#11}
\end{figure}
\end{center}

\begin{onehalfspace}
The below code clip shows a unconditional branch being used:
\end{onehalfspace}
\begin{figure}[H]
\begin{minted}{gas}
/*an assembly code example using the unconditional branch instruction*/
.text
.global main
main:
      mov r0, #11
      b finish /*branch to finish*/
      mov r0, #22
finish:
      bx lr
\end{minted}
\caption{branch instruction}
\end{figure}

\rowcolors{1}{gray!10}{brown!10}
\begin{onehalfspace}
When the above code is run the second mov instruction will be skipped due to the branch instruction pointing to \textit{finish}.
\end{onehalfspace}
\section{The main components of the ARM1176JZF-S}
\begin{onehalfspace}
The following components are considered the main components for the ARM1176JZF-S processor~\citep[1-8]{arm1176jzf-s}:
\subsection{List of components}
\end{onehalfspace}
\begin{description}
\item[Integer Core] The ARM1176JZF-S processor is built around the ARM11 integer core. Therefore, it is a implementation of the ARMv6 architecture. This architecture handles the following critical items~\citep[1-9]{arm1176jzf-s}:
\begin{itemize}
\item Instruction sets
\item Conditional execution
\item Registers
\item Modes and exceptions
\item Thumb instruction set
\item DSP instructions
\item Media extensions
\item Datapath
\item Branch prediction
\item Return Stack
\end{itemize}
\item[Load Store Unit (LSU)] The load-store pipeline decouples loads and stores from the MAC and ALU~\citep[1-11]{arm1176jzf-s}.
\item [Prefetch unit] Fetches instructions from the instruction cache, external memory and instruction TCM to predict branch outcomes~\citep[1-11]{arm1176jzf-s}.
\item [Memory system] The memory system provides the core with features such as virtual indexing, export of memory, memory access control and many other capabilities~\citep[1-12]{arm1176jzf-s}.
\item [AMBA AXI interface] This bus interface allows high bandwidth connectivity between the processor, second level caches, on-chip RAM, peripherals, and interfaces to external memory~\citep[1-16]{arm1176jzf-s}. 
\item [Coprocessor interface] This is a external coprocessor which interfaces with the ARM1176JZF-S to handle ARM coprocessor instructions~\citep[1-17]{arm1176jzf-s}.
\item [Debug] Using the ARMv6 debug architecture the following levels of debugging are allowed~\citep[1-18]{arm1176jzf-s}:
\begin{itemize}
\item debug everywhere
\item debug in non-secure privileged user, and secure user.
\item debug in non-secure.
\end{itemize}
\item [Instruction cycle summary and interlocks] Allows handling of cycle timing behavior.
\item [Vector Floating-Point (VFP)] Handles floating point arithmetic operations~\citep[1-19]{arm1176jzf-s}.
\item [System control] Controls the memory system and other functionality~\citep[1-21]{arm1176jzf-s}.
\item [Interrupt handling] The interrupt handling deal with the following areas~\citep[1-21]{arm1176jzf-s}:
\begin{itemize}
\item Vectors Interrupt Controller port
\item Low interrupt latency configuration
\item Configuration
\item Exception processing enhancements
\end{itemize}
\end{description}
\section{ARM1176JZF-S pipeline stages}
\begin{onehalfspace}
\subsection{The Common Decode Pipeline}
The datapath for the ARM1176JZF-S consists of three pipelines. Each of these pipelines are composed of eight stages.
\begin{itemize}
\item ALU, Shift and Sat pipeline
\item MAC pipeline, also called the Multiply pipeline.
\item Load/Store pipeline
\end{itemize}
The ARM1176JZF-S  processor overlaps operations to improve clock rate speed for each instruction. The following figure 11 illustrates the first 4 stages; Fe1, Fe2, De, Iss are considered the \textbf{common decode pipeline}. From the common decode pipeline the direction taken will be one of three, four step pipelines; The ALU pipeline, Multiply pipeline, or a Load/Store pipeline.
\end{onehalfspace}

\begin{figure}[H]
\begin{tikzpicture}

%Row One
\node[stage2,rotate=90](alup) at (7.5,0){ALU pipeline};
\node[stage2,rotate=90](mulp) at (7.5,-2){Multiply pipeline};
\node[stage2,rotate=90](lsp) at (7.5,-4){Load/Store pipeline};
\node[stage3](cdp) at (-5,-1.4){common decode pipeline};
\node[stage] (s1) at (-8,1.5){Fe1};
\node[box1] (bx1) at (-8,0){1st fetch stage};
\node[stage] (s) at (-6,1.5){Fe2};
\node[box2] (bx2) at (-6,0){2nd fetch stage};
\node[stage] (s3) at (-4,1.5){De};
\node[box3] (bx3) at (-4,0){Instruction decode};
\node[stage] (s4) at (-2,1.5){Iss};
\node[box4] (bx4) at (-2,0){Reg.read and issue};
\node[stage] (e1) at (0,2){Ex1};
\node[stage] (e2) at (2,2){Ex2};
\node[stage] (e3) at (4,2){Ex3};
\node[stage] (s5) at (0,1.5){Sh};
\node[box1] (bx5) at (0,0){Shifter stage};
\node[stage] (s6) at (2,1.5){ALU};
\node[box2] (bx6) at (2,0){ALU\\operation};
\node[stage] (s7) at (4,1.5){Sat};
\node[box3] (bx7) at (4,0){Saturation stage};
\node[stage] (s8) at (6,1.5){WBex};
\node[box4] (bx8) at (6,0){Writeback Mul/ALU};
%Row Two
\node[stage] (s2_1) at (0,-1){MAC1};
\node[box1] (r2bx1) at (0,-2){1st multiply\\acc. stage};
\node[stage] (s2_2) at (2,-1){MAC2};
\node[box2] (r2bx2) at (2,-2){2nd multiply\\acc. stage};
\node[stage] (s2_3) at (4,-1){MAC3};
\node[box3] (r2bx3) at (4,-2){3rd multiply\\acc. stage};
%Row Three
\node[stage] (s3_1) at (0,-3.5){ADD};
\node[box1] (r3bx1) at (0,-4.5){Address generation};
\node[stage] (s3_2) at (2,-3.5){DC1};
\node[box2] (r3bx2) at (2,-4.5){Data cache 1};
\node[stage] (s3_3) at (4,-3.5){DC2};
\node[box3] (r3bx3) at (4,-4.5){Data cache 2};
\node[stage] (s3_4) at (6,-3.5){WBIs};
\node[box4] (r3bx4) at (6,-4.5){Writeback from LSU};
%background
\begin{scope}[on background layer]
\fill[black!50](-9,-1) rectangle(-5,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!10](-5,-1) rectangle(-3,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](-3,-1) rectangle(-1,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!80](-1,-3) rectangle(5,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](-1,-5) rectangle(1,-3);
\end{scope}

\begin{scope}[on background layer]
\fill[black!10](1,-5) rectangle(5,-3);
\end{scope}


\begin{scope}[on background layer]
\fill[black!50](5,-1) rectangle(7,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](5,-5) rectangle(7,-3);
\end{scope}

\end{tikzpicture}

\caption{ARM1176JZF-S pipeline stages}
\end{figure}
\begin{onehalfspace}
\subsection{Fetch stages 1 and 2}
\subsubsection{branch prediction}
The first question you may ask is why two fetch stages? One reason is to provide time for conversion of a virtual address to a physical address. Beyond the integer core pipeline there is also a separate prefetch unit inside the core. The prefetch unit performs dynamic branch prediction. Branch prediction enables the detection of instructions before they enter the integer core~\citep[5-4]{arm1176jzf-s}.
\subsubsection{instruction fetch}
The first stage of instruction fetch deals with memory. Fe1 handles address issuing to memory and data returns from memory~\citep[1-26]{arm1176jzf-s}. If branch prediction handles instructions ahead of the fetch stages, the fetch stage can handle up to four instructions. Instruction fetches are single-copy atomic~\citep{arm7}:
\end{onehalfspace}
\begin{itemize}
\item 32-bit granularity in ARM state.
\item 16-bit granularity in Thumb and ThumbEE states.
\item 8-bit granularity in Jazelle state. 
\end{itemize}
\subsection{Instruction Issue and Decode}
\begin{onehalfspace}
The decode stage literally decodes data by extracting it from register addresses from the current instruction. The Issue and decode stages can contain any instruction in parallel with a predicted branch. 
\subsubsection{the coprocessor and the cores relationship}
The coprocessor interface also has a decode stage which is passed directly from the core. Unlike, the core pipeline the coprocessor does not contain the fetch stages and instead begins with a instruction queue and decoder. The core does not discriminate between coprocessor related instructions or non-coprocessor instructions. Therefore, the coprocessor must react immediately with decoding~\citep[11-14]{arm1176jzf-s}. Other complexities are involved as the core may decide, after passing an instruction, to later cancel the previously passed instruction. For this reason the coprocessor maintains a cancel queue. The coprocessor is directed by the core to cancel the previous instruction by the signal \textbf{ACPCANCEL}. Upon the discovery of the ACPCANCEL signal the coprocessor removes the canceled instruction; the cancellation is handled during the Ex1 stage before moving to Ex2. This is only one small example of the many tasks the coprocessor handles.
\end{onehalfspace}
\section{Instruction Execution Pipeline }
\begin{onehalfspace}
Past the Common Decode Pipeline is the Instruction Execution Pipeline. Each of these pipelines ALU, Multiply, and Load \& Store are composed of four stages, the same as the Common Decode Pipeline. Taking a look at the Program Counter register or R15 we can evaluate when a instruction has reached execution. The 32-bit ARM instructions can be read as the PC + 8, the 16-bit Thumb instructions as PC + 4~\citep[A2-11]{arm7}. The following example of a GDB session demonstrates the registry \textbf{pc} position in relation to execution:
\end{onehalfspace}
\begin{figure}[H]
\begin{minted}{gas}
.text
.global main
main:
      MOV r0, #5
      MOV r1, #10
      MUL r2, r1, r0
finish:
      bx lr
\end{minted}
\caption{32-bit ARM assembly code}
\end{figure}
\begin{figure}[H]
\begin{minted}{gdb}
(gdb) info reg
r0             0x1	1
r1             0xbefff7d4	3204446164
r2             0xbefff7dc	3204446172
r3             0x8390	33680
r4             0x0	0
r5             0x0	0
r6             0x82e4	33508
r7             0x0	0
r8             0x0	0
r9             0x0	0
r10            0xb6fff000	3070226432
r11            0x0	0
r12            0xb6fc1000	3069972480
sp             0xbefff688	0xbefff688
lr             0xb6ead81c	-1226123236
pc             0x8390	0x8390 <main>
cpsr           0x60000010	1610612752
(gdb) disas
Dump of assembler code for function main:
=> 0x00008390 <+0>:	mov	r0, #5        EXECUTE
   0x00008394 <+4>:	mov	r1, #10       DECODE
   0x00008398 <+8>:	mul	r2, r1, r0    FETCH
End of assembler dump.

\end{minted}
\caption{GDB}
\end{figure}
\begin{onehalfspace}
As you can see the \textbf{pc} registry is pointed to the current instruction for execution at address $0x00008390$. Here is another exciting fact, you are looking at the entire fetch, decode and execute cycle right now. As you may have noticed I have appended the text, EXECUTE, DECODE and FETCH to the assembler dump made by the disassemble command.  
\end{onehalfspace}
\subsection{The Shift, ALU and Sat pipeline}
\begin{onehalfspace}
The Shift, ALU and Sat pipeline handles the majority of ALU type operations~\citep[1-10]{arm1176jzf-s}. Additionally, the ARM1176JZF-S uses a 32-bit barrel shifter which works with a second operand before it enters the ALU.
\end{onehalfspace}

%begin ALU operation
\begin{figure}[H]
\begin{tikzpicture}
%Arrows
\node[arrow2](ar1) at (-7,-1){};
\node[arrow2](ar2) at (-5,-1){};
\node[arrow2](ar3) at (-3,-1){};
\node[arrow1](ar4) at (-1,-1){};
\node[arrow1](ar5) at ( 1,-1){};
\node[arrow1](ar6) at ( 3,-1){};
\node[arrow1](ar7) at ( 5,-1){};
%Row One
\node[stage2,rotate=90](alup) at (7.5,0){ALU pipeline};
\node[stage3](cdp) at (-5,-1.8){common decode pipeline};
\node[stage] (e1) at (0,2){Ex1};
\node[stage] (e2) at (2,2){Ex2};
\node[stage] (e3) at (4,2){Ex3};
\node[stage] (s1) at (-8,1.5){Fe1};
\node[box1] (bx1) at (-8,0){1st fetch stage};
\node[stage] (s) at (-6,1.5){Fe2};
\node[box2] (bx2) at (-6,0){2nd fetch stage};
\node[stage] (s3) at (-4,1.5){De};
\node[box3] (bx3) at (-4,0){Instruction decode};
\node[stage] (s4) at (-2,1.5){Iss};
\node[box4] (bx4) at (-2,0){Reg.read and issue};
\node[stage] (s5) at (0,1.5){Sh};
\node[box1] (bx5) at (0,0){Shifter stage};
\node[stage] (s6) at (2,1.5){ALU};
\node[box2] (bx6) at (2,0){ALU\\operation};
\node[stage] (s7) at (4,1.5){Sat};
\node[box3] (bx7) at (4,0){Saturation stage};
\node[stage] (s8) at (6,1.5){WBex};
\node[box4] (bx8) at (6,0){Writeback Mul/ALU};
%Row Two
%background
\begin{scope}[on background layer]
\fill[black!50](-9,-1) rectangle(-5,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!10](-5,-1) rectangle(-3,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](-3,-1) rectangle(-1,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!80](-1,-1) rectangle(5,1);
\end{scope}


\begin{scope}[on background layer]
\fill[black!50](5,-1) rectangle(7,1);
\end{scope}

\end{tikzpicture}
\caption{ARM1176JZF-S ALU Operation}
\end{figure}

\subsubsection{Shift}
\begin{onehalfspace}
The shift stage pertains to the full barrel shifter~\citep{davespace} performing all shifts needed. The barrel shifter is connected to the ALU allowing it to directly pass the second operand after doing its job. A good example of the barrel shift in action is the logical shift left illustrated below:
\begin{figure}[H]
\begin{minted}{gas}
.text
.global main
main:
      movs r0, #2
      mov r0, r0, LSL #1
finish:
      bx lr
\end{minted}
\caption{Logical Shift Left ARM 32-bit}

\end{figure}
In the above example you might notice the LSL is on the tail end of the instruction. This is actually a MOV shifted register. The canonical form or equivalent instruction would be:
\begin{minted}{trac-wiki}
LSL{S} <Rd>, <Rm>,#<n>
\end{minted}
In fact if you disassemble the above code clip with GDB, the instruction will be seen as the LSL instruction, and not a MOV instruction at all:
\begin{figure}[H]
\begin{minted}{gdb}
(gdb) disas
Dump of assembler code for function main:
=> 0x00008390 <+0>:	movs	r0, #2
   0x00008394 <+4>:	lsl	r0, r0, #1
End of assembler dump.
(gdb) x/t 0x00008394
0x8394 <main+4>:	11100001101000000000000010000000
\end{minted}

\caption{Logical Shift Left Assembler Dump}
\end{figure}
\subsubsection{ALU}
The ALU handles all arithmetic and logic operations. The ALU also deals with the conditional codes for instructions. The ALU stage is composed of:
\end{onehalfspace}
\begin{itemize}
\item logic unit
\item arithmetic unit
\item flag generator
\end{itemize}
\subsubsection{Sat}
\begin{onehalfspace} 
The Sat stage implements saturation logic needed by various classes of DSP instructions.
\subsubsection{WBex}
To complete the ALU pipeline there is a write back to a base register during the WBex stage.
\end{onehalfspace}
%begin multiply operation
\begin{figure}[H]
\begin{tikzpicture}
%Arrows
\node[arrow2](ar1) at (-7,-1){};
\node[arrow2](ar2) at (-5,-1){};
\node[arrow2](ar3) at (-3,-1){};
\node[arrow4](ar4) at (-1.5,-1.5){};
\node[arrow3](ar5) at (1,-3){};
\node[arrow3](ar6) at (3,-3){};
\node[arrow5](ar7) at (5.5,-1.6){};

%Row One
\node[stage2,rotate=90](alup) at (7.5,0){ALU pipeline};
\node[stage2,rotate=90](mulp) at (7.5,-2){Multiply pipeline};
\node[stage3](cdp) at (-5,-1.8){common decode pipeline};
\node[stage] (e1) at (0,.5){Ex1};
\node[stage] (e2) at (2,.5){Ex2};
\node[stage] (e3) at (4,.5){Ex3};
\node[stage] (s1) at (-8,1.5){Fe1};
\node[box1] (bx1) at (-8,0){1st fetch stage};
\node[stage] (s) at (-6,1.5){Fe2};
\node[box2] (bx2) at (-6,0){2nd fetch stage};
\node[stage] (s3) at (-4,1.5){De};
\node[box3] (bx3) at (-4,0){Instruction decode};
\node[stage] (s4) at (-2,1.5){Iss};
\node[box4] (bx4) at (-2,0){Reg.read and issue};
\node[stage] (s8) at (6,1.5){WBex};
\node[box4] (bx8) at (6,0){Writeback Mul/ALU};
%Row Two
\node[stage] (s2_1) at (0,-1){MAC1};
\node[box1] (r2bx1) at (0,-2){1st multiply\\acc. stage};
\node[stage] (s2_2) at (2,-1){MAC2};
\node[box2] (r2bx2) at (2,-2){2nd multiply\\acc. stage};
%arrow
\draw[->, color=green, very thick, dashed] (s2_2) to [bend right=45] (s2_1);
\node[stage] (s2_3) at (4,-1){MAC3};
\node[box3] (r2bx3) at (4,-2){3rd multiply\\acc. stage};
%background
\begin{scope}[on background layer]
\fill[black!50](-9,-1) rectangle(-5,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!10](-5,-1) rectangle(-3,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](-3,-1) rectangle(-1,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!80](-1,-3) rectangle(5,0);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](5,-1) rectangle(7,1);
\end{scope}


\end{tikzpicture}
\caption{ARM1176JZF-S Multiply Operation}
\end{figure}
\subsection{Multiply pipeline}
\begin{onehalfspace}
Unlike MAC2 and MAC3, MAC1, the first stage in the multiply pipeline, can loop until it has passed through the first part of the multiplier array enough times. The second half of the array is dealt with by MAC2 and MAC3 until completion~\citep[1-28]{arm1176jzf-s}. To complete the pipeline a write back is done to the base register. The MAC pipeline executes all of the enhanced multiplication instructions~\citep[1-11]{arm1176jzf-s}. 
\end{onehalfspace}
%begin LDR/STR operation
\begin{figure}[H]
\begin{tikzpicture}
%Arrows
\node[arrow2](ar1) at (-7,-1){};
\node[arrow2](ar2) at (-5,-1){};
\node[arrow2](ar3) at (-3,-1){};
\node[arrow1](ar4) at (-1,-1){};
\node[arrow1](ar5) at ( 1,-1){};
\node[arrow1](ar6) at ( 3,-1){};
\node[arrow1](ar7) at ( 5,-1){};
\node[arrow4](ar8) at ( -1.5,-2){};
\node[arrow3](ar9) at (1,-5.3){}; 
\node[arrow3](ar9) at (3,-5.3){}; 
\node[arrow3](ar9) at (5,-5.3){}; 

%Row One
\node[stage2,rotate=90](alup) at (7.5,0){ALU pipeline};
\node[stage2,rotate=90](lsp) at (7.5,-4){Load/Store pipeline};
\node[stage3](cdp) at (-5,-1.8){common decode pipeline};
\node[stage] (e1) at (0,2){Ex1};
\node[stage] (e2) at (2,2){Ex2};
\node[stage] (e3) at (4,2){Ex3};
\node[stage] (s1) at (-8,1.5){Fe1};
\node[box1] (bx1) at (-8,0){1st fetch stage};
\node[stage] (s) at (-6,1.5){Fe2};
\node[box2] (bx2) at (-6,0){2nd fetch stage};
\node[stage] (s3) at (-4,1.5){De};
\node[box3] (bx3) at (-4,0){Instruction decode};
\node[stage] (s4) at (-2,1.5){Iss};
\node[box4] (bx4) at (-2,0){Reg.read and issue};
\node[stage] (s5) at (0,1.5){Sh};
\node[box1] (bx5) at (0,0){Shifter stage};
\node[stage] (s6) at (2,1.5){ALU};
\node[box2] (bx6) at (2,0){ALU\\operation};
\node[stage] (s7) at (4,1.5){Sat};
\node[box3] (bx7) at (4,0){Saturation stage};
\node[stage] (s8) at (6,1.5){WBex};
\node[box4] (bx8) at (6,0){Writeback Mul/ALU};
%Row Three
\node[stage] (s3_1) at (0,-3.5){ADD};
\node[box1] (r3bx1) at (0,-4.5){Address generation};
\node[stage] (s3_2) at (2,-3.5){DC1};
\node[box2] (r3bx2) at (2,-4.5){Data cache 1};
\node[stage] (s3_3) at (4,-3.5){DC2};
\node[box3] (r3bx3) at (4,-4.5){Data cache 2};
\node[stage] (s3_4) at (6,-3.5){WBIs};
\node[box4] (r3bx4) at (6,-4.5){Writeback from LSU};
%background
\begin{scope}[on background layer]
\fill[black!50](-9,-1) rectangle(-5,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!10](-5,-1) rectangle(-3,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](-3,-1) rectangle(-1,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!80](-1,-1) rectangle(5,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](-1,-5) rectangle(1,-3);
\end{scope}

\begin{scope}[on background layer]
\fill[black!10](1,-5) rectangle(5,-3);
\end{scope}


\begin{scope}[on background layer]
\fill[black!50](5,-1) rectangle(7,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](5,-5) rectangle(7,-3);
\end{scope}

\end{tikzpicture}
\caption{ARM1176JZF-S LDR/STR operation }
\end{figure}
\subsection{The Load/Store pipeline}
\begin{onehalfspace}
The Load/Store pipeline consists of the Data address calculation stage followed by two data cache stages. The pipeline completes with a write back of data from the LSU or Load Store Unit. When the processor issues LDM or STM instructions to the LSU, other instructions from the MAC and ALU pipelines run concurrently~\citep[1-11]{arm1176jzf-s}. 
\end{onehalfspace}

%begin LDM/STM op
\begin{figure}[H]
\begin{tikzpicture}
%Arrows
\node[arrow2](ar1) at (-7,-1){};
\node[arrow2](ar2) at (-5,-1){};
\node[arrow2](ar3) at (-3,-1){};
\node[arrow1](ar4) at (-1,-1){};
\node[arrow1](ar5) at ( 1,-1){};
\node[arrow1](ar6) at ( 3,-1){};
\node[arrow1](ar7) at ( 5,-1){};
\node[arrow4](ar8) at ( -1.5,-2){};
\node[arrow3](ar9) at (1,-5.3){}; 
\node[arrow3](ar9) at (3,-5.3){}; 
\node[arrow3](ar9) at (5,-5.3){}; 


%Row One
\node[stage2,rotate=90](alup) at (7.5,0){ALU pipeline};
\node[stage2,rotate=90](lsp) at (7.5,-4){Load/Store pipeline};
\node[stage3](cdp) at (-5,-1.8){common decode pipeline};
\node[stage] (e1) at (0,2){Ex1};
\node[stage] (e2) at (2,2){Ex2};
\node[stage] (e3) at (4,2){Ex3};
\node[stage] (s1) at (-8,1.5){Fe1};
\node[box1] (bx1) at (-8,0){1st fetch stage};
\node[stage] (s) at (-6,1.5){Fe2};
\node[box2] (bx2) at (-6,0){2nd fetch stage};
\node[stage] (s3) at (-4,1.5){De};
\node[box3] (bx3) at (-4,0){Instruction decode};
\node[stage] (s4) at (-2,1.5){Iss};
\node[box4] (bx4) at (-2,0){Reg.read and issue};
\node[stage] (s5) at (0,1.5){Sh};
\node[box1] (bx5) at (0,0){Shifter stage};
\node[stage] (s6) at (2,1.5){ALU};
\node[box2] (bx6) at (2,0){ALU\\operation};
\node[stage] (s7) at (4,1.5){Sat};
\node[box3] (bx7) at (4,0){Saturation stage};
\node[stage] (s8) at (6,1.5){WBex};
\node[box4] (bx8) at (6,0){Writeback Mul/ALU};
%Row Three
\node[stage] (s3_1) at (0,-3.5){ADD};
\node[box1] (r3bx1) at (0,-4.5){Address generation};
\draw[->, color=green, very thick, dashed] (s3_1) to (0,-2.5) to (.5,-2.5) to (.5,-3.4);
\node[stage] (s3_2) at (2,-3.5){DC1};
\node[box2] (r3bx2) at (2,-4.5){Data cache 1};
\node[stage] (s3_3) at (4,-3.5){DC2};
\node[box3] (r3bx3) at (4,-4.5){Data cache 2};
\node[stage] (s3_4) at (6,-3.5){WBIs};
\node[stage] (s3_4) at (2,-6.5){hit under miss};
\node[box5] (r3bx2) at (2,-7.7){used only in event of a miss};
\node[box4] (r3bx4) at (6,-4.5){Writeback from LSU};
%background
\begin{scope}[on background layer]
\fill[black!50](-9,-1) rectangle(-5,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!10](-5,-1) rectangle(-3,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](-3,-1) rectangle(-1,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!80](-1,-1) rectangle(5,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](-1,-5) rectangle(1,-3);
\end{scope}

\begin{scope}[on background layer]
\fill[black!10](1,-5) rectangle(5,-3);
\end{scope}


\begin{scope}[on background layer]
\fill[black!50](5,-1) rectangle(7,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](5,-5) rectangle(7,-3);
\end{scope}

\end{tikzpicture}
\caption{ARM1176JZF-S LDM/STM operation}
\end{figure}
%LDR that misses below

\begin{figure}[H]
\begin{tikzpicture}
%Arrows
\node[arrow2](ar1) at (-7,-1){};
\node[arrow2](ar2) at (-5,-1){};
\node[arrow2](ar3) at (-3,-1){};
\node[arrow1](ar4) at (-1,-1){};
\node[arrow1](ar5) at ( 1,-1){};
\node[arrow1](ar6) at ( 3,-1){};
\node[arrow1](ar7) at ( 5,-1){};
\node[arrow4](ar8) at ( -1.5,-2){};
\node[arrow3](ar9) at (1,-5.3){}; 
\node[arrow3](ar9) at (3,-5.3){}; 
\node[arrow3](ar9) at (5,-5.3){}; 


%Row One
\node[stage2,rotate=90](alup) at (7.5,0){ALU pipeline};
\node[stage2,rotate=90](lsp) at (7.5,-4){Load/Store pipeline};
\node[stage3](cdp) at (-5,-1.8){common decode pipeline};
\node[stage] (e1) at (0,2){Ex1};
\node[stage] (e2) at (2,2){Ex2};
\node[stage] (e3) at (4,2){Ex3};
\node[stage] (s1) at (-8,1.5){Fe1: 1};
\node[box1] (bx1) at (-8,0){1st fetch stage};
\node[stage] (s) at (-6,1.5){Fe2: 2};
\node[box2] (bx2) at (-6,0){2nd fetch stage};
\node[stage] (s3) at (-4,1.5){De: 3};
\node[box3] (bx3) at (-4,0){Instruction decode};
\node[stage] (s4) at (-2,1.5){Iss: 4};
\node[box4] (bx4) at (-2,0){Reg.read and issue};
\node[stage] (s5) at (0,1.5){Sh: 5};
\node[box1] (bx5) at (0,0){Shifter stage};
\node[stage] (s6) at (2,1.5){ALU: 6};
\node[box2] (bx6) at (2,0){ALU\\operation};
\node[stage] (s7) at (4,1.5){Sat: 7};
\node[box3] (bx7) at (4,0){Saturation stage};
\node[stage] (s8) at (6,1.5){WBex: 8};
\node[box4] (bx8) at (6,0){Writeback Mul/ALU};
%Row Three
\node[stage] (s3_1) at (0,-3.5){ADD: 5};
\node[box1] (r3bx1) at (0,-4.5){Address generation};
\node[stage] (s3_2) at (2,-3.5){DC1: 6};
\node[box2] (r3bx2) at (2,-4.5){Data cache 1};
\node[stage] (s3_3) at (4,-3.5){DC2:11};
\node[box3] (r3bx3) at (4,-4.5){Data cache 2};
\node[stage] (s3_4) at (6,-3.5){WBIs: 12};
\node[box4] (r3bx4) at (6,-4.5){Writeback from LSU};
\node[stage] (s3_4) at (2,-6.5){hit under miss: 9, 10};
\node[box5] (r3bx2) at (2,-7.7){Loaded!};
%background
\begin{scope}[on background layer]
\fill[black!50](-9,-1) rectangle(-5,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!10](-5,-1) rectangle(-3,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](-3,-1) rectangle(-1,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!80](-1,-1) rectangle(5,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](-1,-5) rectangle(1,-3);
\end{scope}

\begin{scope}[on background layer]
\fill[black!10](1,-5) rectangle(5,-3);
\end{scope}


\begin{scope}[on background layer]
\fill[black!50](5,-1) rectangle(7,1);
\end{scope}

\begin{scope}[on background layer]
\fill[black!50](5,-5) rectangle(7,-3);
\end{scope}

\end{tikzpicture}
\caption{ARM1176JZF-S Example LDR miss}
\end{figure}


\subsection{Cycle Timing and Instruction Execution}
\begin{onehalfspace}
Both the ALU and Multiply pipelines move together so all instructions finalize at the same moment. Unlike the ALU and Multiply pipelines the load/store pipeline is decoupled and allows the other pipelines to continue afterwards. For example to avoid an instruction from writing to a register before a store multiple has stored that particular register, the register list has a lock latency which determines how many cycles before a write may occur. The ARM1176JZF-S Reference Manual gives this description regarding the use of forwarding~\citep[16-21]{arm1176jzf-s}:
\end{onehalfspace}
\begin{quote}
Extensive forwarding to the Sh, MAC1, ADD, ALU, MAC2, and DC1 stages enables many
dependent instruction sequences to run without pipeline stalls. General forwarding occurs from
the ALU, Sat, WBex and WBls pipeline stages. In addition, the multiplier contains an internal
multiply accumulate forwarding path. Most instructions do not require a register until the ALU
stage. All result latencies are given as the number of cycles until the register is required by a
following instruction in the ALU stage
\end{quote}
\begin{onehalfspace}
\subsubsection{Use of Flags and Condition codes}
According to the ARM1176JZF-S Reference Manual most instructions will execute within one or two cycles unless failing their condition codes. A specific algorithm is given by the manual for determining the number of cycles for multicycle instructions that have a failed condition code~\citep[16-4]{arm1176jzf-s}:
\end{onehalfspace}
\[
Min(NonFailingCycleCount, Max(5 - FlagCycleDistance, 3))
\]
\begin{onehalfspace}
The \textbf{NonFailingCycleCount} variable shown above is the number of cycles the same instruction will take when it passes. The \textbf{FlagCycleDistance} is the distance between two instructions. The first instruction is the flag setter and the second the conditional instruction which relies on it. A good example of a FlagCycleDistance of zero might be~\citep[16-4]{arm1176jzf-s}: 
\end{onehalfspace}
\begin{figure}[H]
\begin{minted}{gas}
ADDS R0, R1, R2
MULEQ R3,R4, R5
\end{minted}
\end{figure}
\begin{onehalfspace}
Notice the operand ADD is ADDS, the S is an opptional suffix, which is a condition code that asks to update all the ALU status flags in the CPSR. Also notice that the MUL operand has the suffix EQ, this is a conditional code for Equal which uses a Z flag. In contrast the below example has a FlagCycleDictance of one, as there is a single instruction between the two aforementioned instructions:
\end{onehalfspace}
\begin{figure}[H]
\begin{minted}{gas}
ADDS R0, R1, R2
MOV R6, R6
MULEQ R3,R4, R5
\end{minted}
\end{figure}
\subsubsection{Register Interlocks}
\begin{onehalfspace}
Interlocks are used to avoid instructions writing to the same register at the same moment and creating a pipeline hazard. The following example takes four cycles~\citep[16-6]{arm1176jzf-s} to complete due to the resultant latency of \textbf{R0}. 
\end{onehalfspace}
\begin{figure}[H]
\begin{minted}{gas}
LDR R0, [R1]
ADD R4, R3, R0
\end{minted}
\end{figure}
\begin{onehalfspace}
However, if the ADD instruction was not waiting on a register from the previous command the instruction sequence would only take two cycles:
\end{onehalfspace}
\begin{figure}[H]
\begin{minted}{gas}
LDR R0, [R1]
ADD R4, R3, R2

\end{minted}
\end{figure}
\section{A note about the ARM11 design}
\begin{onehalfspace}
The ARM design is primarily driven towards low energy consumption. In the past ARM would not have been considered a good solution for mid-sized to large computers such as a web server. The majority of desktop sized computers run on x86 or x86\_64 based processors of one sort or another. The architecture reviewed today is 32-bit and is unlikely to be used in future desktop sized computers, but other ARM based creations are being considered by high-tech companies such as Apple~\citep{apple} and AMD~\citep{amd}. The ARM11 is primarily for smaller hand held devices such as the iPhone, iPad, Linux or Android based phones and Tablets and other smaller devices such as the Raspberry Pi or your Samsung TV. The ARM11 is small enough, energy efficient enough, and designed well enough to run on a small battery for hours. Very few architectures can claim the same capabilities at this time. 
\end{onehalfspace}
\clearpage
\printbibliography

\end{document}
